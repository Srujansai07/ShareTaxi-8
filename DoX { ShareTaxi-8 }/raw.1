üöó RideShare Local - Complete Development Package
Executive Summary
RideShare Local is a hyper-local mobility and social connection platform that enables residents of the same building or locality to coordinate shared rides to common destinations, reducing costs, traffic, and carbon emissions while building community bonds.

üìã PRODUCT REQUIREMENTS DOCUMENT (PRD)
1. Product Overview
1.1 Vision Statement
To become the leading hyper-local mobility platform that transforms how neighbors travel together, reducing urban congestion while fostering community connections.
1.2 Product Positioning
Category: Hyper-local Mobility + Social Networking
Target Market: Urban residential complexes, apartments, hostels, gated communities
Primary Users: Working professionals, students, residents aged 18-55
Geographic Focus: Tier 1 & 2 Indian cities (Bangalore, Hyderabad, Pune, Chennai, Mumbai)
1.3 Success Metrics (KPIs)
User Acquisition: 1,000 registered users in 50 buildings (Month 3)
Engagement: 40% weekly active users
Match Rate: 25% successful ride matches per week
Retention: 60% 30-day retention
Social Impact: 10,000 kg CO2 saved in 6 months
2. Problem Statement
2.1 User Pain Points
Financial Waste: ‚Çπ3,000-5,000/month on individual transportation
Time Inefficiency: Waiting for cabs, traffic congestion
Environmental Impact: Unnecessary carbon emissions
Social Isolation: No connection with neighbors despite proximity
Safety Concerns: Solo travel, especially for women at night
2.2 Market Validation
70% of apartment residents travel to 5 common locations weekly
Average 3-4 rides/week to similar destinations within 30-minute windows
‚Çπ450 billion urban mobility market in India
Growing demand for sustainable transportation solutions
3. Target Users
3.1 Primary Personas
Persona 1: Priya (Working Professional)
Age: 28, Software Engineer
Lives in 500+ unit apartment complex
Commutes to tech park 12 km away
Pain: Spends ‚Çπ4,500/month on Uber, wants to save money and meet neighbors
Persona 2: Rahul (Student)
Age: 22, MBA student
Lives in PG accommodation near university
Pain: Limited budget, wants social connections, safety in numbers
Persona 3: Anjali (Homemaker)
Age: 35, part-time consultant
Pain: Occasional mall/market trips, prefers traveling with known neighbors for safety
4. Core Features & Requirements
4.1 MVP Features (Phase 1 - Months 1-3)
Feature 1: User Registration & Verification
User Story: As a new user, I want to register and verify my building so I can connect with verified neighbors only.
Requirements:
Phone number OTP authentication
Building/locality verification (address + GPS)
Profile creation (name, photo, building/flat number)
Government ID verification (optional for trust score)
Privacy settings (who can see profile)
Acceptance Criteria:
Registration completed in < 3 minutes
99.9% OTP delivery rate
GPS coordinates match registered address within 100m radius
Feature 2: Ride Request Creation
User Story: As a resident, I want to announce where I'm going so others can join me.
Requirements:
Destination input (search + map selection)
Departure time selection (now, +15min, +30min, custom)
Number of available seats
Ride type (own car, shared cab, public transport meetup)
Optional: Cost sharing preference
Ride visibility (building only, locality, extended network)
Acceptance Criteria:
Ride created in < 30 seconds
Real-time visibility to eligible users
Auto-expire after departure time + 15 minutes
Feature 3: Smart Matching Algorithm
User Story: As a user, I want to automatically see who else is going to nearby destinations at similar times.
Requirements:
Proximity matching (destination within 2km)
Time window matching (¬±30 minutes)
Building/locality filtering
Match scoring based on:
Destination proximity (40%)
Time alignment (30%)
User trust score (20%)
Previous interactions (10%)
Acceptance Criteria:
Matches displayed within 2 seconds
90% accuracy in destination proximity
Updates every 30 seconds
Feature 4: In-App Communication
User Story: As a matched user, I want to coordinate the ride details with my neighbor.
Requirements:
In-app chat (text only for MVP)
Pre-defined quick messages ("I'm ready", "Running 5 min late")
Contact sharing (optional, after mutual acceptance)
Block/report functionality
Acceptance Criteria:
Messages delivered within 3 seconds
Push notifications for new messages
Chat history retained for 7 days
Feature 5: Live Ride Tracking
User Story: As a participant, I want to see the live location of my ride partner for coordination.
Requirements:
GPS tracking (active only during ride window)
Live map showing participant locations
ETA calculation
Geofencing for pickup points
Auto-disable tracking 15 min after ride completion
Acceptance Criteria:
Location updates every 10 seconds
Battery consumption < 5% per hour
Privacy: location visible only to ride participants
Feature 6: Trust & Safety System
User Story: As a user, I want to feel safe traveling with neighbors I've just met.
Requirements:
Post-ride rating system (1-5 stars)
Trust score display (average rating + number of completed rides)
Verified badge (ID + address verified)
Emergency SOS button (shares location with emergency contacts + app support)
Community moderation (report user, block user)
Acceptance Criteria:
Rating prompts appear immediately after ride
SOS alert sent within 5 seconds
Reported users reviewed within 24 hours
4.2 Enhanced Features (Phase 2 - Months 4-6)
Feature 7: Recurring Rides
Save frequent routes (home ‚Üí office)
Auto-match with regular commuters
Weekly schedule setup
"Ride buddy" system
Feature 8: Social Features
Building community feed
Event coordination (group outings)
Neighbor discovery (shared interests)
Reputation badges (Eco Warrior, Community Builder)
Feature 9: Multi-Modal Integration
Uber/Ola API integration for split booking
Public transport schedule integration
Walking/cycling meetup coordination
Parking spot sharing
Feature 10: Gamification & Incentives
Points for completed rides
Leaderboards (most eco-friendly, most social)
Rewards: discount coupons, free rides
Referral bonuses
Feature 11: Smart Recommendations
AI-powered destination prediction
Traffic-aware timing suggestions
Cost optimization recommendations
Social compatibility matching
4.3 Advanced Features (Phase 3 - Months 7-12)
Feature 12: Building Admin Portal
Resident verification management
Community announcements
Ride analytics dashboard
Safety incident management
Feature 13: Enterprise Integration
Corporate campus transportation
University student transportation
Hospital staff shift coordination
B2B partnerships
Feature 14: Monetization Features
Premium subscription (advanced matching, priority support)
Commission on ride-sharing payments
Advertising (local businesses)
Data insights for urban planners (anonymized)
5. Technical Requirements
5.1 Performance Requirements
App launch time: < 2 seconds
API response time: < 500ms (p95)
Real-time updates: < 3 seconds latency
Offline capability: Basic ride viewing
Support: 10,000+ concurrent users
5.2 Security Requirements
End-to-end encryption for messages
GDPR-compliant data handling
OAuth 2.0 authentication
Rate limiting on API endpoints
PII data anonymization in logs
Location data encrypted at rest and in transit
5.3 Scalability Requirements
Horizontal scaling for API servers
Database read replicas
CDN for static assets
Redis caching layer
Message queue for async tasks
5.4 Compliance Requirements
IT Act 2000 (India) compliance
Data localization (Indian servers)
User consent management
Right to deletion (GDPR Article 17)
Age verification (18+ only)
6. Non-Functional Requirements
6.1 Usability
Onboarding completion: < 5 minutes
Ride creation: < 1 minute
Maximum 3 clicks to any feature
Support for English, Hindi, Kannada, Telugu
6.2 Reliability
99.9% uptime SLA
Zero data loss guarantee
Automatic failover
Daily backups with 30-day retention
6.3 Accessibility
WCAG 2.1 Level AA compliance
Screen reader support
High contrast mode
Minimum font size: 14px
7. User Flows
7.1 First-Time User Flow
Download app ‚Üí Splash screen
Phone number entry ‚Üí OTP verification
Profile creation (name, photo)
Building verification (address input ‚Üí GPS check)
Tutorial (swipe through 4 screens)
Permission requests (location, notifications)
Home screen
7.2 Create Ride Flow
Home screen ‚Üí Tap "Where are you going?"
Enter destination (autocomplete suggestions)
Select timing (Now / +15min / +30min / Custom)
Set ride details (seats available, ride type)
Confirm ‚Üí Ride goes live
See matches instantly
7.3 Join Ride Flow
See match notification
View ride details (destination, time, user profile)
Tap "I'm interested"
Chat opens automatically
Coordinate pickup point
Track live location
Complete ride ‚Üí Rate experience
8. Design Requirements
8.1 Design Principles
Clarity: Clear information hierarchy
Speed: Minimize user actions
Trust: Prominent safety features
Community: Warm, friendly visual language
Accessibility: High contrast, readable text
8.2 Color Palette
Primary: #2563EB (Blue - Trust)
Secondary: #10B981 (Green - Eco-friendly)
Accent: #F59E0B (Amber - Energy)
Neutral: #6B7280 (Gray)
Error: #EF4444 (Red)
Success: #10B981 (Green)
8.3 Key Screens
Home/Dashboard (active rides, quick create)
Ride Creation (destination search, timing)
Matches List (sorted by relevance)
Ride Detail (user info, chat, map)
Profile (stats, ratings, settings)
Safety Center (SOS, emergency contacts)

üîÑ WORKFLOW DOCUMENTATION
1. Development Workflow
1.1 Sprint Structure (2-week sprints)
Week 1:
- Monday: Sprint planning, story point estimation
- Tuesday-Thursday: Development
- Friday: Code review, PR merges

Week 2:
- Monday-Wednesday: Development, testing
- Thursday: QA testing, bug fixes
- Friday: Sprint demo, retrospective, release

1.2 Git Workflow (Gitflow)
main (production)
  ‚Üë
develop (staging)
  ‚Üë
feature/user-registration
feature/ride-matching
feature/in-app-chat

Branch Naming:
feature/[feature-name]
bugfix/[bug-description]
hotfix/[critical-fix]
Commit Convention:
feat: add ride creation form
fix: resolve GPS permission issue
docs: update API documentation
refactor: optimize matching algorithm
test: add unit tests for user service

1.3 Code Review Process
Developer creates PR with description
Automated tests run (GitHub Actions)
2 peer reviews required
Approval ‚Üí Merge to develop
Automated deployment to staging
2. Data Flow Architecture
2.1 User Registration Flow
User Input ‚Üí Next.js Form
  ‚Üì
Zod Validation
  ‚Üì
Server Action (app/actions/auth.ts)
  ‚Üì
Supabase Auth ‚Üí OTP SMS
  ‚Üì
User confirms OTP
  ‚Üì
Prisma ORM ‚Üí PostgreSQL (users table)
  ‚Üì
JWT Token generated
  ‚Üì
Cookie set (httpOnly, secure)
  ‚Üì
Redirect to /onboarding

2.2 Ride Matching Flow
User creates ride
  ‚Üì
Server Action validates data
  ‚Üì
Insert to rides table (PostgreSQL)
  ‚Üì
Trigger matching algorithm:
  - PostGIS query (nearby destinations)
  - Time window filter (¬±30min)
  - Building/locality filter
  ‚Üì
Calculate match scores
  ‚Üì
Store matches in Redis cache (5 min TTL)
  ‚Üì
WebSocket broadcast to matched users
  ‚Üì
Push notifications sent (Firebase FCM)
  ‚Üì
UI updates in real-time

2.3 Real-Time Location Flow
User location update (every 10s)
  ‚Üì
Client ‚Üí WebSocket connection
  ‚Üì
Next.js API Route (app/api/location/route.ts)
  ‚Üì
Validate user is in active ride
  ‚Üì
Broadcast to ride participants only
  ‚Üì
Update Redis cache (location:userId)
  ‚Üì
PostgreSQL log (for analytics, batched every 5min)

3. State Management Strategy
3.1 Server State (Database)
User profiles, authentication
Rides, matches, ratings
Chat messages (persistent)
Analytics data
3.2 Client State (Zustand)
// stores/useRideStore.ts
{
  activeRide: Ride | null,
  matches: Match[],
  filters: {
    maxDistance: number,
    timeWindow: number
  }
}

// stores/useLocationStore.ts
{
  userLocation: Coordinates | null,
  isTrackingEnabled: boolean,
  participantLocations: Map<userId, Coordinates>
}

// stores/useUIStore.ts
{
  isMatchDrawerOpen: boolean,
  activeTab: 'home' | 'matches' | 'profile',
  notificationPermission: 'granted' | 'denied' | 'pending'
}

3.3 Cache Strategy (React Query)
// Query keys
['rides', 'active'] // Stale time: 30s
['matches', rideId] // Stale time: 1min
['user', userId] // Stale time: 5min
['building', buildingId] // Stale time: 1hour

4. API Architecture
4.1 Server Actions (Primary)
// app/actions/rides.ts
'use server'

export async function createRide(data: RideInput) {
  const session = await getServerSession()
  const validated = rideSchema.parse(data)
  
  const ride = await prisma.ride.create({
    data: { ...validated, userId: session.user.id }
  })
  
  await triggerMatching(ride.id)
  revalidatePath('/dashboard')
  
  return { success: true, rideId: ride.id }
}

4.2 REST API Endpoints (Supplementary)
POST   /api/auth/register
POST   /api/auth/verify-otp
GET    /api/rides/active
POST   /api/rides/create
GET    /api/rides/:id/matches
POST   /api/chat/send
GET    /api/user/profile
PATCH  /api/user/settings
POST   /api/safety/sos

4.3 WebSocket Events
Client ‚Üí Server:
- location_update
- join_ride
- send_message

Server ‚Üí Client:
- new_match
- ride_update
- message_received
- location_broadcast

5. Testing Strategy
5.1 Testing Pyramid
             /\
             /E2E\    (5% - Critical user flows)
            /------\
           /Integ-  \  (15% - API + DB)
          /----------\
         /   Unit     \ (80% - Business logic)
        /--------------\

5.2 Test Coverage Targets
Unit tests: 80% coverage
Integration tests: Key API routes
E2E tests: 5 critical user journeys
Performance tests: Load testing for 1000 concurrent users
5.3 Testing Tools
Unit: Jest + React Testing Library
Integration: Supertest
E2E: Playwright
Load: k6

üìÖ IMPLEMENTATION PLAN
Phase 0: Setup & Infrastructure (Week 1-2)
Week 1: Project Initialization
Days 1-3: Repository & Tooling Setup
[ ] Initialize Next.js 14 project with TypeScript
[ ] Configure ESLint, Prettier, Husky
[ ] Setup Prisma with PostgreSQL
[ ] Configure Supabase project
[ ] Setup Vercel deployment
[ ] Create GitHub repository with branch protection
Days 4-5: Database Design
[ ] Design database schema (ERD)
[ ] Create Prisma schema
[ ] Setup migrations
[ ] Seed development data
[ ] Test database connections
Week 2: Core Infrastructure
Days 1-2: Authentication Foundation
[ ] Implement Supabase Auth
[ ] Create auth middleware
[ ] Setup session management
[ ] Build login/register pages
Days 3-5: UI Foundation
[ ] Install and configure shadcn/ui
[ ] Create design system (colors, typography)
[ ] Build reusable components (Button, Input, Card)
[ ] Setup Tailwind custom configuration
[ ] Create layout components
Phase 1: MVP Development (Week 3-10)
Sprint 1 (Week 3-4): User Registration & Verification
User Stories:
As a user, I can register with my phone number
As a user, I can verify my building address
As a user, I can create my profile
Tasks:
[ ] Phone OTP authentication flow
[ ] Building verification with GPS
[ ] Profile creation form
[ ] Upload profile photo (with compression)
[ ] Building database seeding (top 50 buildings)
[ ] Write unit tests for auth service
Deliverable: Working registration flow
Sprint 2 (Week 5-6): Ride Creation
User Stories:
As a user, I can create a ride request
As a user, I can specify destination and timing
As a user, I can see my active rides
Tasks:
[ ] Ride creation form with validation
[ ] Destination autocomplete (Google Places API)
[ ] Date/time picker component
[ ] Active rides dashboard
[ ] Cancel ride functionality
[ ] Write integration tests for ride CRUD
Deliverable: Ride creation and management
Sprint 3 (Week 7-8): Matching Algorithm
User Stories:
As a user, I can see potential ride matches
As a user, I can filter matches by distance/time
As a user, I can view match profiles
Tasks:
[ ] Implement PostGIS for geospatial queries
[ ] Build matching algorithm (destination + time)
[ ] Create match scoring system
[ ] Build matches list UI
[ ] Implement real-time match updates (WebSocket)
[ ] Performance test matching with 100 sample rides
Deliverable: Working match recommendation system
Sprint 4 (Week 9-10): Communication & Coordination
User Stories:
As a user, I can chat with matched riders
As a user, I can share my live location
As a user, I can set pickup points
Tasks:
[ ] Build in-app chat (WebSocket)
[ ] Implement real-time location tracking
[ ] Create map view with user markers
[ ] Quick message templates
[ ] Push notifications for new messages
[ ] Write E2E test for full ride flow
Deliverable: Complete ride coordination system
Sprint 5 (Week 11-12): Trust & Safety
User Stories:
As a user, I can rate my ride experience
As a user, I can see trust scores
As a user, I can report/block users
As a user, I can trigger SOS alert
Tasks:
[ ] Post-ride rating system
[ ] Trust score calculation
[ ] SOS button with emergency contact notification
[ ] Report/block user functionality
[ ] Admin moderation dashboard (basic)
[ ] Write security audit report
Deliverable: Safety features implemented
Phase 2: Beta Launch (Week 13-14)
Week 13: Testing & Bug Fixes
[ ] QA testing of all user flows
[ ] Fix critical bugs
[ ] Performance optimization
[ ] Security audit
[ ] Load testing (1000 simulated users)
Week 14: Beta Deployment
[ ] Deploy to production (Vercel)
[ ] Setup monitoring (Sentry, LogRocket)
[ ] Create user onboarding tutorial
[ ] Prepare marketing materials
[ ] Soft launch to 3 pilot buildings (50 users)
Phase 3: Iteration & Scaling (Week 15-24)
Weeks 15-18: Feature Enhancement
[ ] Implement recurring rides
[ ] Add social feed
[ ] Integrate Uber/Ola APIs
[ ] Build gamification system
[ ] Develop building admin portal
Weeks 19-22: Growth Features
[ ] Referral program
[ ] Premium subscription tier
[ ] AI-powered recommendations
[ ] Multi-language support
[ ] iOS app development (React Native)
Weeks 23-24: Enterprise Readiness
[ ] B2B partnerships module
[ ] Analytics dashboard
[ ] API for third-party integration
[ ] White-label solution framework

üéØ DETAILED WALKTHROUGH
Walkthrough 1: New User Onboarding (5 minutes)
Step 1: App Launch
Screen: Splash Screen
Duration: 2 seconds
Elements: Logo animation, "Connecting neighbors, one ride at a time" tagline
Action: Auto-navigate to registration
Step 2: Phone Registration
Screen: Registration Screen
Input: Phone number field (+91 prefix auto-filled)
Button: "Get OTP" (disabled until valid 10-digit number)
Validation: Real-time format check
Action: User enters 9876543210 ‚Üí Taps "Get OTP"
Backend: Supabase Auth sends SMS via Twilio
Step 3: OTP Verification
Screen: OTP Input Screen
Input: 6-digit OTP field (auto-focus, auto-submit)
Timer: 30-second resend countdown
Action: User enters OTP ‚Üí Auto-verification
Error Handling: "Invalid OTP" message, allow retry
Step 4: Profile Creation
Screen: Profile Setup
Inputs:
Full Name (required)
Profile Photo (optional, camera/gallery)
Gender (optional dropdown)
Button: "Continue"
Action: User fills details ‚Üí Taps "Continue"
Backend: Create user record in PostgreSQL
Step 5: Building Verification
Screen: Building Verification
Method 1: GPS Auto-detect
Permission request ‚Üí "Allow location access"
Show detected address ‚Üí User confirms
Method 2: Manual Search
Search bar with autocomplete
Display list of registered buildings
User selects building ‚Üí Enters flat/unit number
Action: User confirms "Prestige Tech Park, Tower A, Flat 502"
Backend: Verify GPS coordinates match building database
Step 6: Tutorial
Screen: Swipeable Tutorial (4 screens)
"Create a ride in 30 seconds"
"Get matched with neighbors instantly"
"Chat and coordinate pickup"
"Rate your experience, build trust"
Action: Swipe through or "Skip" button
Step 7: Permissions
Screen: Permission Requests
Location: "We need location to match you with nearby rides"
Notifications: "Get alerts when someone matches your ride"
Action: User grants both ‚Üí Navigate to Home
Result: User arrives at Home Dashboard (empty state)

Walkthrough 2: Creating & Matching a Ride (10 minutes)
Step 1: Initiate Ride Creation
Screen: Home Dashboard
UI: Large search bar "Where are you going?"
Quick Actions: "To Office" (if recurring ride exists), "To Mall", "Custom"
Action: User taps search bar ‚Üí Destination input screen
Step 2: Enter Destination
Screen: Destination Search
Input: Search bar with autocomplete (powered by Google Places API)
Behavior:
User types "Kormangala" ‚Üí Suggestions appear
Shows: "Koramangala, Bangalore" (area), "Koramangala Metro Station", "Koramangala Forum Mall"
Map: Interactive map showing user's location and destination pin
Action: User selects "Koramangala, Bangalore" ‚Üí Proceeds to timing
Step 3: Set Timing
Screen: Ride Timing
Options:
üöÄ "Leaving Now" (highlighted)
‚è±Ô∏è "In 15 minutes"
‚è±Ô∏è "In 30 minutes"
üìÖ "Choose Time" (opens time picker)
Additional: Departure location (home address pre-filled, editable)
Action: User selects "In 15 minutes" ‚Üí Proceeds to ride details
Step 4: Ride Details
Screen: Ride Configuration
Ride Type (single select):
üöó Own car (I'm driving, seats available: dropdown 1-4)
üöñ Shared cab (split Uber/Ola cost)
üöå Public transport (metro/bus meetup)
üö∂ Walking/Cycling buddy
Cost Sharing: Toggle "Split costs equally" (default: ON)
Preferences:
Gender preference (Any/Same gender only) - especially for safety
Max detour distance (0.5 km / 1 km / 2 km slider)
Action: User selects "Own car, 2 seats", toggle cost sharing ON ‚Üí Taps "Create Ride"
Step 5: Ride Goes Live
Screen: Active Ride View
Header: "Looking for matches..." (animated pulsing circle)
Ride Summary Card:
Destination: Koramangala, Bangalore
Departure: Today, 3:45 PM (15 min from now)
Type: Own car, 2 seats available
Timer: Countdown "Leaving in 14:32"
Action Buttons:
"Cancel Ride"
"Edit Details"
Step 6: Match Found! (30 seconds later)
Screen: Match Notification
Notification: Banner at top "üéâ Ravi Kumar from Flat 608 is also going to Koramangala!"
Match Card Appears:
 [Profile Photo] Ravi Kumar ‚≠ê 4.8 (12 rides)üìç Flat 608, Tower AüéØ Koramangala (Food Street) - 0.3 km from your destination‚è∞ Leaving in 13 minutesüöñ Looking for shared cab[View Profile] [I'm Interested]


Action: User taps "I'm Interested"
Step 7: Chat Opens
Screen: Ride Chat
Auto-Message: "Hi Ravi! I'm also heading to Koramangala. Want to share a ride?"
Quick Actions:
"I'm ready to leave"
"I'll be 5 minutes late"
"Let's meet at the main gate"
"Share Live Location"
Action: Ravi responds "Sure! Let's meet at the main gate in 10 min"
User Sends: "Perfect, I'll be there!"
Step 8: Coordinate Pickup
Screen: Live Tracking
Map View:
User's location (blue marker)
Ravi's location (green marker)
Pickup point (red pin at main gate)
Distance: "Ravi is 80m away"
ETA: "2 minutes to pickup point"
Chat: Still accessible via bottom sheet
Step 9: Ride Started
Screen: Ongoing Ride
Status: "Ride in Progress"
Map: Showing route to destination
Participants:
You (Driver)
Ravi Kumar (Passenger)
Actions:
"End Ride" (for driver)
"SOS" button (prominent, red)
"Chat" (quick access)
Step 10: Ride Completion
Screen: Ride Complete
Confirmation: "You've arrived! üéâ"
Stats:
Distance: 6.2 km
Time: 23 minutes
Saved: ‚Çπ85 (split cost)
CO2 Saved: 1.2 kg
Action: "Rate Your Ride"
Step 11: Rating
Screen: Ride Rating
Rate Ravi: 5-star selector
Quick Tags: Punctual, Friendly, Respectful, Good conversation
Optional: Text feedback
Action: User rates 5 stars + "Punctual, Friendly" ‚Üí Taps "Submit"
Result: Return to Home Dashboard with ride history updated

Walkthrough 3: Safety Scenario - Using SOS Feature
Scenario: User feels unsafe during ride coordination
Step 1: Trigger SOS
Screen: Any screen with SOS button (always visible)
Action: User long-presses SOS button (3 seconds to prevent accidental triggers)
Confirmation: "Are you in danger? Hold to activate SOS"
Step 2: SOS Activated
Screen: SOS Alert Screen
Immediate Actions:
Live location sent to 3 emergency contacts (pre-configured)
Alert sent to app support team
Ride participants notified (if in active ride)
Local police station details displayed
UI:
Large "EMERGENCY" header (red)
User's live location map
"Call Police" button (direct dial 100)
"Call Emergency Contact" (tap to call)
"I'm Safe Now" button
Step 3: Support Response
Screen: Support Chat
Auto-Connect: Priority support chat opens
Support Message: "We've received your SOS. Are you safe? What do you need?"
User Can:
Send current situation update
Share photos/videos
Request support actions (block user, escalate to police)
Step 4: Resolution
Screen: SOS Deactivation
Action: User confirms "I'm Safe Now"
Follow-up:
"What happened?" incident report form
Option to block/report user involved
Support team follow-up call scheduled
Result: Incident logged, user account protected

üìä JSON FORMATTING EXAMPLES
1. User Profile JSON
{
  "user": {
    "id": "usr_a1b2c3d4e5f6",
    "phoneNumber": "+919876543210",
    "profile": {
      "fullName": "Priya Sharma",
      "displayName": "Priya",
      "photoUrl": "https://cdn.ridesharelocal.app/users/usr_a1b2c3d4e5f6/profile.jpg",
      "gender": "female",
      "dateOfBirth": "1995-03-15",
      "memberSince": "2025-01-15

T10:30:00Z" }, "building": { "id": "bld_prestige_tech_park_a", "name": "Prestige Tech Park", "tower": "Tower A", "flatNumber": "502", "address": { "street": "Kadubeesanahalli", "area": "Marathahalli", "city": "Bangalore", "state": "Karnataka", "pincode": "560103", "country": "India" }, "coordinates": { "latitude": 12.9352, "longitude": 77.6908 }, "verified": true, "verifiedAt": "2025-01-15T10:35:00Z", "verificationMethod": "gps" }, "trustScore": { "rating": 4.8, "totalRides": 47, "completionRate": 0.94, "responseTime": "2min", "badges": ["verified", "eco-warrior", "punctual", "friendly"], "level": "trusted_neighbor" }, "preferences": { "genderPreference": "any", "smokingAllowed": false, "musicPreference": "any", "chatty": true, "maxDetourKm": 1.5, "preferredLanguages": ["english", "hindi", "kannada"] }, "emergencyContacts": [ { "name": "Raj Sharma", "relationship": "spouse", "phoneNumber": "+919876543211", "isPrimary": true }, { "name": "Anita Sharma", "relationship": "mother", "phoneNumber": "+919876543212", "isPrimary": false } ], "notifications": { "push": true, "sms": false, "email": true, "matchAlerts": true, "messageAlerts": true, "rideReminders": true }, "privacy": { "profileVisibility": "building_only", "showPhoneNumber": false, "showFlatNumber": true, "showRideHistory": false, "allowDirectMessages": true }, "statistics": { "totalDistanceSaved": 294.5, "totalMoneySaved": 3890, "totalCO2Saved": 58.9, "totalRides": 47, "asDriver": 23, "asPassenger": 24, "newConnectionsMade": 18, "recurringRideBuddies": 5 }, "status": "active", "createdAt": "2025-01-15T10:30:00Z", "updatedAt": "2025-02-10T08:15:00Z", "lastActiveAt": "2025-02-10T08:15:00Z" } }

## 2. Ride Request JSON

```json
{
  "ride": {
    "id": "ride_x7y8z9a0b1c2",
    "userId": "usr_a1b2c3d4e5f6",
    "status": "active",
    "type": "own_car",
    "origin": {
      "type": "building",
      "buildingId": "bld_prestige_tech_park_a",
      "address": "Prestige Tech Park, Tower A, Marathahalli",
      "coordinates": {
        "latitude": 12.9352,
        "longitude": 77.6908
      },
      "pickupPoint": {
        "description": "Main Gate",
        "coordinates": {
          "latitude": 12.9355,
          "longitude": 77.6910
        }
      }
    },
    "destination": {
      "placeId": "ChIJbU60yXAWrjsR4E9-UejD3_g",
      "name": "Koramangala",
      "address": "Koramangala, Bangalore, Karnataka 560095",
      "coordinates": {
        "latitude": 12.9279,
        "longitude": 77.6271
      },
      "estimatedArrivalRadius": 2000
    },
    "timing": {
      "departureTime": "2025-02-10T15:45:00Z",
      "createdAt": "2025-02-10T15:30:00Z",
      "flexibilityMinutes": 15,
      "isImmediate": false,
      "expiresAt": "2025-02-10T16:00:00Z"
    },
    "capacity": {
      "totalSeats": 3,
      "availableSeats": 2,
      "occupiedSeats": 1
    },
    "costSharing": {
      "enabled": true,
      "estimatedTotal": 250,
      "perPerson": 125,
      "currency": "INR",
      "paymentMethod": "split_later"
    },
    "preferences": {
      "genderPreference": "any",
      "maxDetourKm": 1.0,
      "allowSmoking": false,
      "petsAllowed": false
    },
    "route": {
      "distance": 6200,
      "duration": 1380,
      "polyline": "encoded_polyline_string_here",
      "trafficCondition": "moderate"
    },
    "participants": [
      {
        "userId": "usr_a1b2c3d4e5f6",
        "role": "driver",
        "joinedAt": "2025-02-10T15:30:00Z",
        "status": "confirmed"
      }
    ],
    "matches": [
      {
        "matchId": "mtch_d3e4f5g6h7i8",
        "userId": "usr_j9k0l1m2n3o4",
        "score": 0.92,
        "reasons": ["destination_proximity", "time_match", "high_trust_score"],
        "status": "pending",
        "createdAt": "2025-02-10T15:31:00Z"
      }
    ],
    "visibility": "building_only",
    "metadata": {
      "purpose": "commute",
      "tags": ["work", "evening"],
      "notes": "Heading to Koramangala for dinner"
    },
    "createdAt": "2025-02-10T15:30:00Z",
    "updatedAt": "2025-02-10T15:31:00Z"
  }
}

3. Match Algorithm Response JSON
{
  "matches": [
    {
      "matchId": "mtch_d3e4f5g6h7i8",
      "score": 0.92,
      "confidence": "high",
      "user": {
        "id": "usr_j9k0l1m2n3o4",
        "displayName": "Ravi Kumar",
        "photoUrl": "https://cdn.ridesharelocal.app/users/usr_j9k0l1m2n3o4/profile.jpg",
        "building": {
          "flatNumber": "608",
          "tower": "Tower A"
        },
        "trustScore": {
          "rating": 4.8,
          "totalRides": 12,
          "badges": ["verified", "punctual"]
        }
      },
      "ride": {
        "id": "ride_p5q6r7s8t9u0",
        "type": "shared_cab",
        "destination": {
          "name": "Koramangala Food Street",
          "coordinates": {
            "latitude": 12.9283,
            "longitude": 77.6275
          }
        },
        "timing": {
          "departureTime": "2025-02-10T15:43:00Z",
          "flexibilityMinutes": 10
        }
      },
      "compatibility": {
        "destinationProximity": {
          "distanceMeters": 340,
          "score": 0.95,
          "weight": 0.40
        },
        "timeAlignment": {
          "differenceMinutes": 2,
          "score": 0.98,
          "weight": 0.30
        },
        "trustScore": {
          "value": 4.8,
          "score": 0.96,
          "weight": 0.20
        },
        "previousInteractions": {
          "count": 0,
          "score": 0.70,
          "weight": 0.10
        }
      },
      "benefits": {
        "estimatedSavings": 85,
        "co2Reduction": 1.2,
        "detourDistance": 340,
        "additionalTime": 3
      },
      "status": "available",
      "createdAt": "2025-02-10T15:31:00Z",
      "expiresAt": "2025-02-10T15:50:00Z"
    },
    {
      "matchId": "mtch_v1w2x3y4z5a6",
      "score": 0.78,
      "confidence": "medium",
      "user": {
        "id": "usr_b7c8d9e0f1g2",
        "displayName": "Sneha Patel",
        "photoUrl": "https://cdn.ridesharelocal.app/users/usr_b7c8d9e0f1g2/profile.jpg",
        "building": {
          "flatNumber": "312",
          "tower": "Tower B"
        },
        "trustScore": {
          "rating": 4.5,
          "totalRides": 8,
          "badges": ["verified"]
        }
      },
      "ride": {
        "id": "ride_h3i4j5k6l7m8",
        "type": "public_transport",
        "destination": {
          "name": "Koramangala Metro Station",
          "coordinates": {
            "latitude": 12.9320,
            "longitude": 77.6251
          }
        },
        "timing": {
          "departureTime": "2025-02-10T15:55:00Z",
          "flexibilityMinutes": 5
        }
      },
      "compatibility": {
        "destinationProximity": {
          "distanceMeters": 1850,
          "score": 0.72,
          "weight": 0.40
        },
        "timeAlignment": {
          "differenceMinutes": 10,
          "score": 0.80,
          "weight": 0.30
        },
        "trustScore": {
          "value": 4.5,
          "score": 0.90,
          "weight": 0.20
        },
        "previousInteractions": {
          "count": 0,
          "score": 0.70,
          "weight": 0.10
        }
      },
      "benefits": {
        "estimatedSavings": 0,
        "co2Reduction": 2.5,
        "detourDistance": 1850,
        "additionalTime": 12
      },
      "status": "available",
      "createdAt": "2025-02-10T15:31:00Z",
      "expiresAt": "2025-02-10T16:00:00Z"
    }
  ],
  "metadata": {
    "totalMatches": 2,
    "searchRadius": 3000,
    "timeWindow": 30,
    "appliedFilters": {
      "buildingOnly": true,
      "maxDetour": 2000,
      "genderPreference": "any"
    },
    "searchedAt": "2025-02-10T15:31:00Z",
    "nextRefresh": "2025-02-10T15:31:30Z"
  }
}

4. Chat Message JSON
{
  "message": {
    "id": "msg_n9o0p1q2r3s4",
    "conversationId": "conv_t5u6v7w8x9y0",
    "rideId": "ride_x7y8z9a0b1c2",
    "senderId": "usr_a1b2c3d4e5f6",
    "recipientId": "usr_j9k0l1m2n3o4",
    "type": "text",
    "content": {
      "text": "Hi Ravi! I'm also heading to Koramangala. Want to share a ride?",
      "richContent": null
    },
    "metadata": {
      "isQuickReply": false,
      "isSystemMessage": false,
      "deliveryStatus": "delivered",
      "readStatus": "read",
      "readAt": "2025-02-10T15:32:15Z"
    },
    "attachments": [],
    "reactions": [],
    "timestamp": "2025-02-10T15:32:00Z"
  }
}

5. Location Update JSON (WebSocket)
{
  "event": "location_update",
  "data": {
    "userId": "usr_a1b2c3d4e5f6",
    "rideId": "ride_x7y8z9a0b1c2",
    "location": {
      "latitude": 12.9354,
      "longitude": 77.6909,
      "accuracy": 15.5,
      "altitude": 920,
      "bearing": 135.2,
      "speed": 8.5
    },
    "status": {
      "isMoving": true,
      "distanceToPickup": 45,
      "etaToPickup": 120,
      "distanceToDestination": 6200,
      "etaToDestination": 1380
    },
    "timestamp": "2025-02-10T15:33:00Z",
    "batteryLevel": 78
  }
}

6. Ride Rating JSON
{
  "rating": {
    "id": "rat_z1a2b3c4d5e6",
    "rideId": "ride_x7y8z9a0b1c2",
    "raterId": "usr_a1b2c3d4e5f6",
    "ratedUserId": "usr_j9k0l1m2n3o4",
    "score": 5,
    "aspects": {
      "punctuality": 5,
      "communication": 5,
      "cleanliness": 5,
      "driving": 5,
      "friendliness": 5
    },
    "tags": ["punctual", "friendly", "good_conversation"],
    "feedback": "Great ride! Ravi was on time and very friendly. Would definitely ride with him again.",
    "isPublic": true,
    "metadata": {
      "wouldRideAgain": true,
      "addToFavorites": true
    },
    "timestamp": "2025-02-10T16:15:00Z"
  }
}

7. SOS Alert JSON
{
  "sosAlert": {
    "id": "sos_f7g8h9i0j1k2",
    "userId": "usr_a1b2c3d4e5f6",
    "rideId": "ride_x7y8z9a0b1c2",
    "severity": "critical",
    "status": "active",
    "location": {
      "latitude": 12.9301,
      "longitude": 77.6285,
      "accuracy": 12.3,
      "address": "Koramangala 5th Block, Bangalore"
    },
    "context": {
      "triggerMethod": "long_press",
      "rideStatus": "in_progress",
      "otherParticipants": ["usr_j9k0l1m2n3o4"]
    },
    "notifications": {
      "emergencyContacts": [
        {
          "contactId": "emg_l3m4n5o6p7q8",
          "name": "Raj Sharma",
          "phoneNumber": "+919876543211",
          "notifiedAt": "2025-02-10T16:00:01Z",
          "status": "sent"
        },
        {
          "contactId": "emg_r9s0t1u2v3w4",
          "name": "Anita Sharma",
          "phoneNumber": "+919876543212",
          "notifiedAt": "2025-02-10T16:00:01Z",
          "status": "sent"
        }
      ],
      "supportTeam": {
        "notifiedAt": "2025-02-10T16:00:02Z",
        "assignedAgentId": "sup_x5y6z7a8b9c0",
        "status": "acknowledged"
      },
      "rideParticipants": {
        "notifiedAt": "2025-02-10T16:00:01Z",
        "status": "sent"
      }
    },
    "response": {
      "supportChatId": "chat_d1e2f3g4h5i6",
      "policeStationContact": {
        "name": "Koramangala Police Station",
        "phoneNumber": "080-25532222",
        "distance": 1.2
      },
      "actions": [
        {
          "type": "location_share",
          "status": "active",
          "recipients": ["emergency_contacts", "support_team"]
        },
        {
          "type": "audio_recording",
          "status": "recording",
          "startedAt": "2025-02-10T16:00:05Z"
        }
      ]
    },
    "resolution": {
      "status": "pending",
      "resolvedAt": null,
      "resolvedBy": null,
      "outcome": null
    },
    "createdAt": "2025-02-10T16:00:00Z",
    "updatedAt": "2025-02-10T16:00:05Z"
  }
}

8. Analytics Event JSON
{
  "event": {
    "id": "evt_j7k8l9m0n1o2",
    "type": "ride_completed",
    "userId": "usr_a1b2c3d4e5f6",
    "sessionId": "ses_p3q4r5s6t7u8",
    "timestamp": "2025-02-10T16:08:00Z",
    "properties": {
      "rideId": "ride_x7y8z9a0b1c2",
      "rideType": "own_car",
      "participantCount": 2,
      "distance": 6.2,
      "duration": 23,
      "moneySaved": 85,
      "co2Saved": 1.2,
      "matchTimeSeconds": 78,
      "completionRate": 1.0,
      "wasOnTime": true,
      "detourDistance": 0.34,
      "rating": 5
    },
    "context": {
      "platform": "android",
      "appVersion": "1.0.0",
      "buildNumber": "42",
      "osVersion": "14",
      "deviceModel": "Samsung Galaxy S23",
      "locale": "en_IN",
      "timezone": "Asia/Kolkata",
      "networkType": "wifi"
    },
    "location": {
      "city": "Bangalore",
      "state": "Karnataka",
      "country": "India"
    }
  }
}


üîß TOML CONFIGURATION FILES
1. Project Configuration (rideshare.toml)
[project]
name = "RideShare Local"
version = "1.0.0"
description = "Hyper-local ride-sharing and neighbor coordination platform"
repository = "https://github.com/yourusername/rideshare-local"
license = "MIT"
authors = ["Your Name <your.email@example.com>"]

[project.urls]
homepage = "https://ridesharelocal.app"
documentation = "https://docs.ridesharelocal.app"
support = "https://support.ridesharelocal.app"

[environment]
node_version = "20.x"
npm_version = "10.x"
timezone = "Asia/Kolkata"
default_locale = "en_IN"

[features]
web_search = true
real_time_matching = true
in_app_chat = true
location_tracking = true
push_notifications = true
sos_alerts = true
ride_history = true
gamification = false  # Phase 2
recurring_rides = false  # Phase 2
social_feed = false  # Phase 2

[limits]
max_active_rides_per_user = 3
max_participants_per_ride = 6
max_chat_message_length = 500
max_profile_photo_size_mb = 5
max_building_radius_meters = 500
max_destination_radius_km = 50
max_ride_duration_hours = 6

2. Database Configuration (prisma/config.toml)
[database]
provider = "postgresql"
url_env = "DATABASE_URL"
shadow_database_url_env = "SHADOW_DATABASE_URL"

[database.connection_pool]
max_connections = 20
min_connections = 2
connection_timeout_seconds = 30
idle_timeout_seconds = 600

[database.performance]
statement_cache_size = 500
prepared_statements = true
binary_protocol = true

[migrations]
auto_migrate = false  # Manual migration in production
migrate_on_startup = true  # Dev/staging only

[seeding]
enabled = true
seed_file = "prisma/seed.ts"

[backup]
enabled = true
frequency = "daily"
retention_days = 30

3. Authentication Configuration (config/auth.toml)
[auth]
provider = "supabase"
session_duration_hours = 720  # 30 days
refresh_token_duration_days = 90
require_email_verification = false
require_phone_verification = true

[auth.otp]
provider = "twilio"
code_length = 6
expiry_minutes = 10
max_attempts = 3
rate_limit_per_hour = 5
resend_cooldown_seconds = 30

[auth.jwt]
algorithm = "HS256"
issuer = "rideshare-local"
audience = "rideshare-local-app"

[auth.security]
password_min_length = 8
require_uppercase = false
require_numbers = false
require_special_chars = false
max_login_attempts = 5
lockout_duration_minutes = 15

[auth.social]
google_enabled = false  # Phase 2
facebook_enabled = false  # Phase 2

4. Matching Algorithm Configuration (config/matching.toml)
[matching]
algorithm_version = "1.0"
enabled = true
real_time_updates = true
update_interval_seconds = 30

[matching.radius]
default_destination_km = 2.0
max_destination_km = 5.0
default_detour_km = 1.0
max_detour_km = 3.0

[matching.time_window]
default_minutes = 30
max_minutes = 120
min_minutes = 5

[matching.scoring]
[matching.scoring.weights]
destination_proximity = 0.40
time_alignment = 0.30
trust_score = 0.20
previous_interactions = 0.10

[matching.scoring.thresholds]
minimum_score = 0.60
high_confidence = 0.85
medium_confidence = 0.70
low_confidence = 0.60

[matching.filters]
same_building_only = true
same_gender_option = true
verified_users_only = false
minimum_trust_score = 3.0

[matching.limits]
max_matches_per_ride = 10
max_concurrent_matches = 5
match_expiry_minutes = 15

5. Notification Configuration (config/notifications.toml)
[notifications]
provider = "firebase_fcm"
enabled = true
batch_processing = true
batch_size = 100

[notifications.push]
enabled = true
quiet_hours_start = "22:00"
quiet_hours_end = "07:00"
respect_dnd = true

[notifications.types]
[notifications.types.match_found]
enabled = true
priority = "high"
sound = "match_alert"
vibration = true
title = "üéâ Match Found!"
body = "{username} is going to {destination}"

[notifications.types.message_received]
enabled = true
priority = "normal"
sound = "message_tone"
vibration = true
title = "New message from {username}"
body = "{message_preview}"

[notifications.types.ride_reminder]
enabled = true
priority = "high"
sound = "reminder"
vibration = true
advance_minutes = 10
title = "Ride Starting Soon"
body = "Your ride to {destination} starts in {minutes} minutes"

[notifications.types.sos_alert]
enabled = true
priority = "urgent"
sound = "emergency"
vibration = true
persistent = true
title = "üö® EMERGENCY ALERT"
body = "{username} has triggered an SOS"

[notifications.email]
enabled = true
provider = "sendgrid"
from_address = "noreply@ridesharelocal.app"
from_name = "RideShare Local"

[notifications.sms]
enabled = true
provider = "twilio"
use_for_critical_only = true

6. Location Services Configuration (config/location.toml)
[location]
provider = "native_gps"
fallback_provider = "network"
required_accuracy_meters = 50

[location.tracking]
enabled = true
update_interval_seconds = 10
min_distance_meters = 5
max_age_seconds = 30
battery_optimization = true

[location.tracking.modes]
[location.tracking.modes.active_ride]
interval_seconds = 10
accuracy = "high"
battery_priority = "balanced"

[location.tracking.modes.waiting]
interval_seconds = 30
accuracy = "medium"
battery_priority = "low_power"

[location.tracking.modes.background]
enabled = false
interval_seconds = 300
accuracy = "low"

[location.geofencing]
enabled = true
pickup_radius_meters = 100
building_radius_meters = 200

[location.privacy]
share_with_matched_users_only = true
auto_disable_after_ride = true
disable_delay_minutes = 15
anonymize_in_analytics = true

[location.maps]
provider = "google_maps"
api_key_env = "GOOGLE_MAPS_API_KEY"
default_zoom = 15
min_zoom = 10
max_zoom = 20

7. Performance & Monitoring (config/monitoring.toml)
[monitoring]
enabled = true
environment = "production"

[monitoring.sentry]
enabled = true
dsn_env = "SENTRY_DSN"
traces_sample_rate = 0.1
profiles_sample_rate = 0.1
capture_console = false
attach_stacktrace = true

[monitoring.analytics]
provider = "mixpanel"
api_key_env = "MIXPANEL_TOKEN"
track_pageviews = true
track_user_properties = true

[monitoring.logging]
level = "info"
format = "json"
output = "stdout"

[monitoring.logging.levels]
development = "debug"
staging = "info"
production = "warn"

[monitoring.performance]
[monitoring.performance.web_vitals]
track_fcp = true  # First Contentful Paint
track_lcp = true  # Largest Contentful Paint
track_fid = true  # First Input Delay
track_cls = true  # Cumulative Layout Shift
track_ttfb = true  # Time to First Byte

[monitoring.performance.thresholds]
api_response_ms = 500
page_load_ms = 3000
database_query_ms = 100

[monitoring.alerts]
enabled = true
email_recipients = ["ops@ridesharelocal.app"]
slack_webhook_env = "SLACK_WEBHOOK_URL"

[monitoring.alerts.conditions]
error_rate_threshold = 0.05
response_time_p95_ms = 1000
uptime_threshold = 0.999

8. Rate Limiting Configuration (config/rate_limits.toml)
[rate_limits]
enabled = true
storage = "redis"
key_prefix = "ratelimit:"

[rate_limits.api]
[rate_limits.api.default]
window_seconds = 60
max_requests = 100

[rate_limits.api.auth]
window_seconds = 3600
max_requests = 10
message = "Too many authentication attempts"

[rate_limits.api.ride_creation]
window_seconds = 300
max_requests = 5
message = "You can create maximum 5 rides per 5 minutes"

[rate_limits.api.messages]
window_seconds = 60
max_requests = 30
message = "Too many messages sent"

[rate_limits.api.location_updates]
window_seconds = 60
max_requests = 60
message = "Location update limit exceeded"

[rate_limits.websocket]
connection_limit_per_user = 3
messages_per_second = 10

9. Cache Configuration (config/cache.toml)
[cache]
enabled = true
provider = "redis"
url_env = "REDIS_URL"
key_prefix = "rsl:"

[cache.ttl]
user_profile = 300  # 5 minutes
building_data = 3600  # 1 hour
active_rides = 30  # 30 seconds
matches = 60  # 1 minute
chat_messages = 300  # 5 minutes
location_data = 10  # 10 seconds

[cache.strategies]
user_profile = "cache-first"
active_rides = "network-first"
matches = "stale-while-revalidate"
building_data = "cache-only"

[cache.invalidation]
on_user_update = ["user_profile"]
on_ride_update = ["active_rides", "matches"]
on_building_update = ["building_data"]

10. Feature Flags Configuration (config/features.toml)
[features]
provider = "launchdarkly"
api_key_env = "LAUNCHDARKLY_SDK_KEY"

[features.flags]
[features.flags.ride_matching]
enabled = true
rollout_percentage = 100
environments = ["development", "staging", "production"]

[features.flags.in_app_chat]
enabled = true
rollout_percentage = 100
environments = ["development", "staging", "production"]

[features.flags.location_tracking]
enabled = true
rollout_percentage = 100
environments = ["development", "staging", "production"]

[features.flags.recurring_rides]
enabled = false
rollout_percentage = 0
environments = ["development"]
target_release = "1.1.0"

[features.flags.social_feed]
enabled = false
rollout_percentage = 0
environments = ["development"]
target_release = "1.2.0"

[features.flags.gamification]
enabled = false
rollout_percentage = 10
environments = ["development", "staging"]
target_release = "1.2.0"

[features.flags.uber_ola_integration]
enabled = false
rollout_percentage = 0
environments = []
target_release = "1.3.0"


üèó
üèóÔ∏è DETAILED IMPLEMENTATION GUIDE
1. Database Schema Design
Prisma Schema (prisma/schema.prisma)
// This is your Prisma schema file

generator client {
  provider = "prisma-client-js"
  previewFeatures = ["postgresqlExtensions"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  extensions = [postgis]
}

// ============================================
// USER MANAGEMENT
// ============================================

model User {
  id            String   @id @default(cuid())
  phoneNumber   String   @unique
  email         String?  @unique
  
  // Profile
  fullName      String
  displayName   String
  photoUrl      String?
  gender        Gender?
  dateOfBirth   DateTime?
  bio           String?
  
  // Building Information
  buildingId    String
  building      Building @relation(fields: [buildingId], references: [id])
  tower         String?
  flatNumber    String
  
  // Verification
  isVerified    Boolean  @default(false)
  verifiedAt    DateTime?
  verificationMethod VerificationMethod?
  govIdType     String?
  govIdNumber   String?  @unique
  
  // Trust & Safety
  trustScore    Float    @default(3.0)
  totalRides    Int      @default(0)
  completionRate Float   @default(0.0)
  responseTime  Int?     // Average in minutes
  
  // Preferences
  preferences   UserPreferences?
  
  // Emergency Contacts
  emergencyContacts EmergencyContact[]
  
  // Relationships
  ridesAsDriver    Ride[]       @relation("DriverRides")
  ridesAsParticipant RideParticipant[]
  sentMessages     Message[]    @relation("SentMessages")
  receivedMessages Message[]    @relation("ReceivedMessages")
  givenRatings     Rating[]     @relation("RaterUser")
  receivedRatings  Rating[]     @relation("RatedUser")
  sosAlerts        SOSAlert[]
  notifications    Notification[]
  
  // Statistics
  stats         UserStatistics?
  
  // Status
  status        UserStatus @default(ACTIVE)
  lastActiveAt  DateTime   @default(now())
  
  createdAt     DateTime   @default(now())
  updatedAt     DateTime   @updatedAt
  
  @@index([buildingId])
  @@index([phoneNumber])
  @@index([status])
  @@index([trustScore])
}

model UserPreferences {
  id                String  @id @default(cuid())
  userId            String  @unique
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Ride Preferences
  genderPreference  GenderPreference @default(ANY)
  smokingAllowed    Boolean @default(false)
  petsAllowed       Boolean @default(false)
  musicPreference   String  @default("any")
  chatty            Boolean @default(true)
  maxDetourKm       Float   @default(1.5)
  
  // Language
  preferredLanguages String[] @default(["english"])
  
  // Notifications
  pushEnabled       Boolean @default(true)
  smsEnabled        Boolean @default(false)
  emailEnabled      Boolean @default(true)
  matchAlerts       Boolean @default(true)
  messageAlerts     Boolean @default(true)
  rideReminders     Boolean @default(true)
  
  // Privacy
  profileVisibility ProfileVisibility @default(BUILDING_ONLY)
  showPhoneNumber   Boolean @default(false)
  showFlatNumber    Boolean @default(true)
  showRideHistory   Boolean @default(false)
  allowDirectMessages Boolean @default(true)
  
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
}

model UserStatistics {
  id                    String  @id @default(cuid())
  userId                String  @unique
  user                  User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  totalDistanceSaved    Float   @default(0) // in km
  totalMoneySaved       Float   @default(0) // in INR
  totalCO2Saved         Float   @default(0) // in kg
  totalRides            Int     @default(0)
  ridesAsDriver         Int     @default(0)
  ridesAsPassenger      Int     @default(0)
  newConnectionsMade    Int     @default(0)
  recurringRideBuddies  Int     @default(0)
  
  // Badges
  badges                String[] @default([])
  level                 String   @default("newcomer")
  points                Int      @default(0)
  
  updatedAt             DateTime @updatedAt
}

model EmergencyContact {
  id           String @id @default(cuid())
  userId       String
  user         User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  name         String
  relationship String
  phoneNumber  String
  isPrimary    Boolean @default(false)
  
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  
  @@index([userId])
}

// ============================================
// BUILDING MANAGEMENT
// ============================================

model Building {
  id              String   @id @default(cuid())
  name            String
  type            BuildingType
  
  // Address
  street          String
  area            String
  city            String
  state           String
  pincode         String
  country         String   @default("India")
  
  // Location (PostGIS)
  latitude        Float
  longitude       Float
  location        Unsupported("geography(Point,4326)")?
  
  // Metadata
  totalUnits      Int?
  totalFloors     Int?
  towers          String[] @default([])
  
  // Verification
  isVerified      Boolean  @default(false)
  verifiedBy      String?  // Admin user ID
  
  // Relations
  users           User[]
  rides           Ride[]
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  @@index([city, area])
  @@index([pincode])
}

// ============================================
// RIDE MANAGEMENT
// ============================================

model Ride {
  id              String   @id @default(cuid())
  
  // Owner
  userId          String
  user            User     @relation("DriverRides", fields: [userId], references: [id])
  
  // Status
  status          RideStatus @default(ACTIVE)
  
  // Type
  type            RideType
  
  // Origin
  buildingId      String
  building        Building @relation(fields: [buildingId], references: [id])
  originAddress   String
  originLat       Float
  originLng       Float
  pickupPoint     String?
  pickupLat       Float?
  pickupLng       Float?
  
  // Destination
  destinationName String
  destinationAddress String
  destinationLat  Float
  destinationLng  Float
  destinationPlaceId String?
  estimatedArrivalRadius Int @default(2000) // meters
  
  // Timing
  departureTime   DateTime
  flexibilityMinutes Int @default(15)
  isImmediate     Boolean @default(false)
  expiresAt       DateTime
  
  // Capacity
  totalSeats      Int @default(1)
  availableSeats  Int @default(1)
  
  // Cost Sharing
  costSharingEnabled Boolean @default(true)
  estimatedCost   Float?
  costPerPerson   Float?
  currency        String @default("INR")
  
  // Preferences
  genderPreference GenderPreference @default(ANY)
  maxDetourKm     Float @default(1.0)
  allowSmoking    Boolean @default(false)
  allowPets       Boolean @default(false)
  
  // Route Information
  routeDistance   Int? // meters
  routeDuration   Int? // seconds
  routePolyline   String?
  trafficCondition String?
  
  // Metadata
  purpose         String?
  tags            String[] @default([])
  notes           String?
  visibility      RideVisibility @default(BUILDING_ONLY)
  
  // Relations
  participants    RideParticipant[]
  matches         Match[]
  messages        Message[]
  ratings         Rating[]
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  @@index([userId])
  @@index([buildingId])
  @@index([status])
  @@index([departureTime])
  @@index([expiresAt])
}

model RideParticipant {
  id          String @id @default(cuid())
  
  rideId      String
  ride        Ride   @relation(fields: [rideId], references: [id], onDelete: Cascade)
  
  userId      String
  user        User   @relation(fields: [userId], references: [id])
  
  role        ParticipantRole
  status      ParticipantStatus @default(PENDING)
  
  joinedAt    DateTime @default(now())
  confirmedAt DateTime?
  leftAt      DateTime?
  
  // Cost split
  agreedCost  Float?
  paidAmount  Float?
  paymentStatus PaymentStatus @default(PENDING)
  
  @@unique([rideId, userId])
  @@index([rideId])
  @@index([userId])
  @@index([status])
}

// ============================================
// MATCHING SYSTEM
// ============================================

model Match {
  id          String @id @default(cuid())
  
  // Source Ride
  sourceRideId String
  sourceRide   Ride   @relation(fields: [sourceRideId], references: [id], onDelete: Cascade)
  
  // Target User & Ride
  targetUserId String
  targetRideId String?
  
  // Scoring
  score        Float
  confidence   MatchConfidence
  
  // Compatibility Breakdown
  destinationProximityScore Float
  timeAlignmentScore        Float
  trustScoreCompatibility   Float
  previousInteractionsScore Float
  
  // Distances & Times
  destinationDistance Int  // meters
  timeDifference      Int  // minutes
  detourDistance      Int? // meters
  additionalTime      Int? // minutes
  
  // Benefits
  estimatedSavings Float?
  co2Reduction     Float?
  
  // Status
  status          MatchStatus @default(PENDING)
  
  // Metadata
  reasons         String[] @default([])
  
  createdAt       DateTime @default(now())
  expiresAt       DateTime
  respondedAt     DateTime?
  
  @@index([sourceRideId])
  @@index([targetUserId])
  @@index([status])
  @@index([score])
  @@index([createdAt])
}

// ============================================
// COMMUNICATION
// ============================================

model Conversation {
  id          String @id @default(cuid())
  
  rideId      String?
  
  // Participants (array of user IDs)
  participants String[]
  
  // Metadata
  lastMessageAt DateTime?
  messageCount  Int @default(0)
  
  // Relations
  messages    Message[]
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@index([rideId])
}

model Message {
  id              String @id @default(cuid())
  
  conversationId  String
  conversation    Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  
  rideId          String?
  ride            Ride? @relation(fields: [rideId], references: [id], onDelete: Cascade)
  
  senderId        String
  sender          User @relation("SentMessages", fields: [senderId], references: [id])
  
  recipientId     String?
  recipient       User? @relation("ReceivedMessages", fields: [recipientId], references: [id])
  
  // Content
  type            MessageType @default(TEXT)
  content         String
  richContent     Json?
  
  // Attachments
  attachmentType  String?
  attachmentUrl   String?
  
  // Status
  deliveryStatus  DeliveryStatus @default(SENT)
  readStatus      ReadStatus @default(UNREAD)
  readAt          DateTime?
  
  // Metadata
  isQuickReply    Boolean @default(false)
  isSystemMessage Boolean @default(false)
  replyToId       String?
  
  createdAt       DateTime @default(now())
  
  @@index([conversationId])
  @@index([rideId])
  @@index([senderId])
  @@index([recipientId])
  @@index([createdAt])
}

// ============================================
// RATING & TRUST
// ============================================

model Rating {
  id              String @id @default(cuid())
  
  rideId          String
  ride            Ride @relation(fields: [rideId], references: [id])
  
  raterId         String
  rater           User @relation("RaterUser", fields: [raterId], references: [id])
  
  ratedUserId     String
  ratedUser       User @relation("RatedUser", fields: [ratedUserId], references: [id])
  
  // Overall Score
  score           Int // 1-5
  
  // Detailed Aspects
  punctuality     Int?
  communication   Int?
  cleanliness     Int?
  driving         Int?
  friendliness    Int?
  
  // Feedback
  tags            String[] @default([])
  feedback        String?
  
  // Metadata
  isPublic        Boolean @default(true)
  wouldRideAgain  Boolean @default(true)
  addedToFavorites Boolean @default(false)
  
  createdAt       DateTime @default(now())
  
  @@unique([rideId, raterId, ratedUserId])
  @@index([ratedUserId])
  @@index([score])
}

// ============================================
// LOCATION TRACKING
// ============================================

model LocationUpdate {
  id              String @id @default(cuid())
  
  userId          String
  rideId          String?
  
  latitude        Float
  longitude       Float
  accuracy        Float
  altitude        Float?
  bearing         Float?
  speed           Float?
  
  // Status
  isMoving        Boolean @default(false)
  distanceToPickup Int?
  etaToPickup     Int?
  distanceToDestination Int?
  etaToDestination Int?
  
  timestamp       DateTime @default(now())
  batteryLevel    Int?
  
  @@index([userId, timestamp])
  @@index([rideId, timestamp])
}

// ============================================
// SAFETY & SECURITY
// ============================================

model SOSAlert {
  id              String @id @default(cuid())
  
  userId          String
  user            User @relation(fields: [userId], references: [id])
  
  rideId          String?
  
  severity        SOSSeverity
  status          SOSStatus @default(ACTIVE)
  
  // Location
  latitude        Float
  longitude       Float
  accuracy        Float
  address         String?
  
  // Context
  triggerMethod   String
  rideStatus      String?
  otherParticipants String[] @default([])
  
  // Notifications Sent
  notifiedEmergencyContacts Boolean @default(false)
  notifiedSupportTeam       Boolean @default(false)
  notifiedParticipants      Boolean @default(false)
  
  // Response
  supportChatId   String?
  assignedAgentId String?
  policeNotified  Boolean @default(false)
  
  // Resolution
  resolvedAt      DateTime?
  resolvedBy      String?
  outcome         String?
  notes           String?
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  @@index([userId])
  @@index([status])
  @@index([severity])
  @@index([createdAt])
}

model BlockedUser {
  id              String @id @default(cuid())
  
  blockerId       String
  blockedUserId   String
  
  reason          String?
  reportCategory  String?
  details         String?
  
  createdAt       DateTime @default(now())
  
  @@unique([blockerId, blockedUserId])
  @@index([blockerId])
  @@index([blockedUserId])
}

// ============================================
// NOTIFICATIONS
// ============================================

model Notification {
  id              String @id @default(cuid())
  
  userId          String
  user            User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  type            NotificationType
  title           String
  body            String
  
  // Data Payload
  data            Json?
  
  // Deep Link
  actionUrl       String?
  
  // Status
  read            Boolean @default(false)
  readAt          DateTime?
  
  // Delivery
  sentVia         String[] @default([]) // ["push", "email", "sms"]
  delivered       Boolean @default(false)
  deliveredAt     DateTime?
  
  createdAt       DateTime @default(now())
  
  @@index([userId, read])
  @@index([type])
  @@index([createdAt])
}

// ============================================
// ANALYTICS & EVENTS
// ============================================

model AnalyticsEvent {
  id              String @id @default(cuid())
  
  userId          String?
  sessionId       String
  
  eventType       String
  eventName       String
  
  // Properties
  properties      Json?
  
  // Context
  platform        String
  appVersion      String
  osVersion       String
  deviceModel     String
  locale          String
  timezone        String
  networkType     String
  
  // Location
  city            String?
  state           String?
  country         String?
  
  timestamp       DateTime @default(now())
  
  @@index([userId, timestamp])
  @@index([eventType, timestamp])
  @@index([sessionId])
}

// ============================================
// ENUMS
// ============================================

enum Gender {
  MALE
  FEMALE
  NON_BINARY
  PREFER_NOT_TO_SAY
}

enum GenderPreference {
  ANY
  SAME_GENDER
  MALE
  FEMALE
}

enum VerificationMethod {
  GPS
  MANUAL
  ADMIN_VERIFIED
}

enum UserStatus {
  ACTIVE
  INACTIVE
  SUSPENDED
  BANNED
  DELETED
}

enum ProfileVisibility {
  PUBLIC
  BUILDING_ONLY
  LOCALITY_ONLY
  PRIVATE
}

enum BuildingType {
  APARTMENT
  GATED_COMMUNITY
  PG_HOSTEL
  INDEPENDENT_HOUSE
  COMMERCIAL
  MIXED_USE
}

enum RideType {
  OWN_CAR
  SHARED_CAB
  PUBLIC_TRANSPORT
  WALKING
  CYCLING
  TWO_WHEELER
}

enum RideStatus {
  ACTIVE
  IN_PROGRESS
  COMPLETED
  CANCELLED
  EXPIRED
}

enum RideVisibility {
  BUILDING_ONLY
  LOCALITY
  EXTENDED_NETWORK
}

enum ParticipantRole {
  DRIVER
  PASSENGER
  CO_PASSENGER
}

enum ParticipantStatus {
  PENDING
  CONFIRMED
  DECLINED
  LEFT
  COMPLETED
}

enum PaymentStatus {
  PENDING
  PAID
  DECLINED
  REFUNDED
}

enum MatchConfidence {
  HIGH
  MEDIUM
  LOW
}

enum MatchStatus {
  PENDING
  ACCEPTED
  DECLINED
  EXPIRED
}

enum MessageType {
  TEXT
  LOCATION
  QUICK_REPLY
  SYSTEM
}

enum DeliveryStatus {
  SENT
  DELIVERED
  FAILED
}

enum ReadStatus {
  UNREAD
  READ
}

enum SOSSeverity {
  CRITICAL
  HIGH
  MEDIUM
}

enum SOSStatus {
  ACTIVE
  ACKNOWLEDGED
  RESOLVED
  FALSE_ALARM
}

enum NotificationType {
  MATCH_FOUND
  MESSAGE_RECEIVED
  RIDE_REMINDER
  RIDE_STARTED
  RIDE_COMPLETED
  RATING_REQUEST
  SOS_ALERT
  SYSTEM_ANNOUNCEMENT
}


2. Core Server Actions
Authentication Actions (app/actions/auth.ts)
'use server'

import { z } from 'zod'
import { cookies } from 'next/headers'
import { createClient } from '@/lib/supabase/server'
import { prisma } from '@/lib/prisma'
import { redirect } from 'next/navigation'

const phoneSchema = z.object({
  phoneNumber: z.string().regex(/^\+91[6-9]\d{9}$/, 'Invalid Indian phone number')
})

const otpSchema = z.object({
  phoneNumber: z.string(),
  otp: z.string().length(6, 'OTP must be 6 digits')
})

const profileSchema = z.object({
  fullName: z.string().min(2).max(100),
  displayName: z.string().min(2).max(50),
  gender: z.enum(['MALE', 'FEMALE', 'NON_BINARY', 'PREFER_NOT_TO_SAY']).optional(),
  dateOfBirth: z.string().optional()
})

export async function sendOTP(formData: FormData) {
  try {
    const validated = phoneSchema.parse({
      phoneNumber: formData.get('phoneNumber')
    })

    const supabase = createClient()
    
    const { data, error } = await supabase.auth.signInWithOtp({
      phone: validated.phoneNumber,
      options: {
        channel: 'sms'
      }
    })

    if (error) {
      return { success: false, error: error.message }
    }

    return { success: true, message: 'OTP sent successfully' }
  } catch (error) {
    if (error instanceof z.ZodError) {
      return { success: false, error: error.errors[0].message }
    }
    return { success: false, error: 'Failed to send OTP' }
  }
}

export async function verifyOTP(formData: FormData) {
  try {
    const validated = otpSchema.parse({
      phoneNumber: formData.get('phoneNumber'),
      otp: formData.get('otp')
    })

    const supabase = createClient()
    
    const { data, error } = await supabase.auth.verifyOtp({
      phone: validated.phoneNumber,
      token: validated.otp,
      type: 'sms'
    })

    if (error) {
      return { success: false, error: error.message }
    }

    // Check if user exists in database
    const existingUser = await prisma.user.findUnique({
      where: { phoneNumber: validated.phoneNumber }
    })

    if (!existingUser) {
      // New user - redirect to profile creation
      return { success: true, isNewUser: true, redirectTo: '/onboarding/profile' }
    }

    return { success: true, isNewUser: false, redirectTo: '/dashboard' }
  } catch (error) {
    if (error instanceof z.ZodError) {
      return { success: false, error: error.errors[0].message }
    }
    return { success: false, error: 'Failed to verify OTP' }
  }
}

export async function createProfile(formData: FormData) {
  try {
    const supabase = createClient()
    const { data: { user: authUser } } = await supabase.auth.getUser()
    
    if (!authUser) {
      return { success: false, error: 'Not authenticated' }
    }

    const validated = profileSchema.parse({
      fullName: formData.get('fullName'),
      displayName: formData.get('displayName'),
      gender: formData.get('gender'),
      dateOfBirth: formData.get('dateOfBirth')
    })

    // Handle photo upload if provided
    let photoUrl = null
    const photoFile = formData.get('photo') as File
    if (photoFile && photoFile.size > 0) {
      const { data: uploadData, error: uploadError } = await supabase.storage
        .from('profile-photos')
        .upload(`${authUser.id}/${Date.now()}.jpg`, photoFile, {
          cacheControl: '3600',
          upsert: false
        })

      if (!uploadError) {
        const { data: { publicUrl } } = supabase.storage
          .from('profile-photos')
          .getPublicUrl(uploadData.path)
        photoUrl = publicUrl
      }
    }

    // This will be completed in building verification
    // For now, we'll create a partial user record
    const user = await prisma.user.create({
      data: {
        phoneNumber: authUser.phone!,
        ...validated,
        photoUrl,
        // Temporary building assignment - will be updated
        buildingId: 'temp',
        flatNumber: 'pending'
      }
    })

    return { success: true, userId: user.id, redirectTo: '/onboarding/building' }
  } catch (error) {
    if (error instanceof z.ZodError) {
      return { success: false, error: error.errors[0].message }
    }
    console.error('Profile creation error:', error)
    return { success: false, error: 'Failed to create profile' }
  }
}

export async function logout() {
  const supabase = createClient()
  await supabase.auth.signOut()
  redirect('/login')
}

Ride Actions (app/actions/rides.ts)
'use server'

import { z } from 'zod'
import { prisma } from '@/lib/prisma'
import { getServerSession } from '@/lib/auth'
import { revalidatePath } from 'next/cache'
import { triggerMatching } from '@/lib/matching/algorithm'
import { sendPushNotification } from '@/lib/notifications'

const createRideSchema = z.object({
  type: z.enum(['OWN_CAR', 'SHARED_CAB', 'PUBLIC_TRANSPORT', 'WALKING', 'CYCLING']),
  destinationName: z.string().min(1),
  destinationAddress: z.string().min(1),
  destinationLat: z.number(),
  destinationLng: z.number(),
  destinationPlaceId: z.string().optional(),
  departureTime: z.string().datetime(),
  flexibilityMinutes: z.number().min(0).max(120).default(15),
  totalSeats: z.number().min(1).max(6).default(1),
  costSharingEnabled: z.boolean().default(true),
  estimatedCost: z.number().optional(),
  genderPreference: z.enum(['ANY', 'SAME_GENDER', 'MALE', 'FEMALE']).default('ANY'),
  maxDetourKm: z.number().min(0).max(5).default(1.0),
  purpose: z.string().optional(),
  notes: z.string().optional()
})

export async function createRide(formData: FormData) {
  try {
    const session = await getServerSession()
    if (!session?.user) {
      return { success: false, error: 'Not authenticated' }
    }

    const user = await prisma.user.findUnique({
      where: { id: session.user.id },
      include: { building: true }
    })

    if (!user) {
      return { success: false, error: 'User not found' }
    }

    const rawData = {
      type: formData.get('type'),
      destinationName: formData.get('destinationName'),
      destinationAddress: formData.get('destinationAddress'),
      destinationLat: parseFloat(formData.get('destinationLat') as string),
      destinationLng: parseFloat(formData.get('destinationLng') as string),
      destinationPlaceId: formData.get('destinationPlaceId'),
      departureTime: formData.get('departureTime'),
      flexibilityMinutes: parseInt(formData.get('flexibilityMinutes') as string || '15'),
      totalSeats: parseInt(formData.get('totalSeats') as string || '1'),
      costSharingEnabled: formData.get('costSharingEnabled') === 'true',
      estimatedCost: formData.get('estimatedCost') ? parseFloat(formData.get('estimatedCost') as string) : undefined,
      genderPreference: formData.get('genderPreference') || 'ANY',
      maxDetourKm: parseFloat(formData.get('maxDetourKm') as string || '1.0'),
      purpose: formData.get('purpose'),
      notes: formData.get('notes')
    }

    const validated = createRideSchema.parse(rawData)

    const departureTime = new Date(validated.departureTime)
    const expiresAt = new Date(departureTime.getTime() + (validated.flexibilityMinutes + 15) * 60000)

    const ride = await prisma.ride.create({
      data: {
        userId: user.id,
        buildingId: user.buildingId,
        originAddress: user.building.street + ', ' + user.building.area,
        originLat: user.building.latitude,
        originLng: user.building.longitude,
        ...validated,
        departureTime,
        expiresAt,
        availableSeats: validated.totalSeats,
        costPerPerson: validated.estimatedCost ? validated.estimatedCost / validated.totalSeats : undefined,
        isImmediate: Date.now() - departureTime.getTime() < 300000 // Within 5 minutes
      }
    })

    // Add creator as driver participant
    await prisma.rideParticipant.create({
      data: {
        rideId: ride.id,
        userId: user.id,
        role: 'DRIVER',
        status: 'CONFIRMED'
      }
    })

    // Trigger matching algorithm
    await triggerMatching(ride.id)

    revalidatePath('/dashboard')

    return { 
      success: true, 
      rideId: ride.id,
      message: 'Ride created successfully'
    }
  } catch (error) {
    if (error instanceof z.ZodError) {
      return { success: false, error: error.errors[0].message }
    }
    console.error('Ride creation error:', error)
    return { success: false, error: 'Failed to create ride' }
  }
}

export async function cancelRide(rideId: string) {
  try {
    const session = await getServerSession()
    if (!session?.user) {
      return { success: false, error: 'Not authenticated' }
    }

    const ride = await prisma.ride.findUnique({
      where: { id: rideId },
      include: { participants: true }
    })

    if (!ride) {
      return { success: false, error: 'Ride not found' }
    }

    if (ride.userId !== session.user.id) {
      return { success: false, error: 'Not authorized' }
    }

    await prisma.ride.update({
      where: { id: rideId },
      data: { status: 'CANCELLED' }
    })

    // Notify all participants
    const participants = ride.participants.filter(p => p.userId !== session.user.

id)
for (const participant of participants) {
  await sendPushNotification(participant.userId, {
    title: 'Ride Cancelled',
    body: `The ride to ${ride.destinationName} has been cancelled by the organizer.`,
    data: { rideId: ride.id, type: 'ride_cancelled' }
  })
}

revalidatePath('/dashboard')
revalidatePath(`/rides/${rideId}`)

return { success: true, message: 'Ride cancelled successfully' }

} catch (error) { console.error('Cancel ride error:', error) return { success: false, error: 'Failed to cancel ride' } } }
export async function joinRide(rideId: string, matchId?: string) { try { const session = await getServerSession() if (!session?.user) { return { success: false, error: 'Not authenticated' } }
const ride = await prisma.ride.findUnique({
  where: { id: rideId },
  include: { participants: true }
})

if (!ride) {
  return { success: false, error: 'Ride not found' }
}

if (ride.availableSeats <= 0) {
  return { success: false, error: 'No seats available' }
}

// Check if already joined
const existingParticipant = ride.participants.find(p => p.userId === session.user.id)
if (existingParticipant) {
  return { success: false, error: 'Already joined this ride' }
}

// Add participant
await prisma.rideParticipant.create({
  data: {
    rideId: ride.id,
    userId: session.user.id,
    role: 'PASSENGER',
    status: 'CONFIRMED',
    agreedCost: ride.costPerPerson
  }
})

// Update available seats
await prisma.ride.update({
  where: { id: rideId },
  data: { availableSeats: { decrement: 1 } }
})

// Update match status if provided
if (matchId) {
  await prisma.match.update({
    where: { id: matchId },
    data: { status: 'ACCEPTED', respondedAt: new Date() }
  })
}

// Notify ride organizer
await sendPushNotification(ride.userId, {
  title: 'New Rider Joined!',
  body: `Someone joined your ride to ${ride.destinationName}`,
  data: { rideId: ride.id, type: 'participant_joined' }
})

revalidatePath(`/rides/${rideId}`)

return { success: true, message: 'Successfully joined ride' }

} catch (error) { console.error('Join ride error:', error) return { success: false, error: 'Failed to join ride' } } }
export async function getActiveRides() { try { const session = await getServerSession() if (!session?.user) { return { success: false, error: 'Not authenticated' } }
const rides = await prisma.ride.findMany({
  where: {
    OR: [
      { userId: session.user.id },
      { 
        participants: {
          some: { userId: session.user.id }
        }
      }
    ],
    status: { in: ['ACTIVE', 'IN_PROGRESS'] },
    expiresAt: { gt: new Date() }
  },
  include: {
    user: {
      select: {
        id: true,
        displayName: true,
        photoUrl: true,
        trustScore: true
      }
    },
    participants: {
      include: {
        user: {
          select: {
            id: true,
            displayName: true,
            photoUrl: true,
            trustScore: true
          }
        }
      }
    },
    building: {
      select: {
        name: true,
        area: true
      }
    }
  },
  orderBy: { departureTime: 'asc' }
})

return { success: true, rides }

} catch (error) { console.error('Get active rides error:', error) return { success: false, error: 'Failed to fetch rides' } } }
export async function updateRideStatus(rideId: string, status: 'IN_PROGRESS' | 'COMPLETED') { try { const session = await getServerSession() if (!session?.user) { return { success: false, error: 'Not authenticated' } }
const ride = await prisma.ride.findUnique({
  where: { id: rideId },
  include: { participants: true }
})

if (!ride) {
  return { success: false, error: 'Ride not found' }
}

if (ride.userId !== session.user.id) {
  return { success: false, error: 'Not authorized' }
}

await prisma.ride.update({
  where: { id: rideId },
  data: { status }
})

if (status === 'COMPLETED') {
  // Update participant statuses
  await prisma.rideParticipant.updateMany({
    where: { rideId: rideId, status: 'CONFIRMED' },
    data: { status: 'COMPLETED' }
  })

  // Update user statistics
  for (const participant of ride.participants) {
    await prisma.user.update({
      where: { id: participant.userId },
      data: {
        totalRides: { increment: 1 }
      }
    })

    if (participant.userId !== ride.userId) {
      await prisma.userStatistics.upsert({
        where: { userId: participant.userId },
        update: {
          totalRides: { increment: 1 },
          ridesAsPassenger: { increment: 1 },
          totalDistanceSaved: { increment: (ride.routeDistance || 0) / 1000 },
          totalMoneySaved: { increment: participant.agreedCost || 0 },
          totalCO2Saved: { increment: ((ride.routeDistance || 0) / 1000) * 0.21 }
        },
        create: {
          userId: participant.userId,
          totalRides: 1,
          ridesAsPassenger: 1,
          totalDistanceSaved: (ride.routeDistance || 0) / 1000,
          totalMoneySaved: participant.agreedCost || 0,
          totalCO2Saved: ((ride.routeDistance || 0) / 1000) * 0.21
        }
      })
    }
  }

  // Update driver statistics
  await prisma.userStatistics.upsert({
    where: { userId: ride.userId },
    update: {
      totalRides: { increment: 1 },
      ridesAsDriver: { increment: 1 }
    },
    create: {
      userId: ride.userId,
      totalRides: 1,
      ridesAsDriver: 1
    }
  })

  // Request ratings from all participants
  for (const participant of ride.participants) {
    await sendPushNotification(participant.userId, {
      title: 'How was your ride?',
      body: `Rate your experience to help build trust in the community`,
      data: { rideId: ride.id, type: 'rating_request' }
    })
  }
}

revalidatePath(`/rides/${rideId}`)

return { success: true, message: `Ride marked as ${status}` }

} catch (error) { console.error('Update ride status error:', error) return { success: false, error: 'Failed to update ride status' } } }

### Matching Algorithm (`lib/matching/algorithm.ts`)

```typescript
import { prisma } from '@/lib/prisma'
import { sendPushNotification } from '@/lib/notifications'
import { calculateDistance, calculateTimeDifference } from '@/lib/utils/geo'

interface MatchScore {
  destinationProximity: number
  timeAlignment: number
  trustScore: number
  previousInteractions: number
  overall: number
}

const WEIGHTS = {
  destinationProximity: 0.40,
  timeAlignment: 0.30,
  trustScore: 0.20,
  previousInteractions: 0.10
}

const THRESHOLDS = {
  minimumScore: 0.60,
  highConfidence: 0.85,
  mediumConfidence: 0.70
}

export async function triggerMatching(rideId: string) {
  try {
    const ride = await prisma.ride.findUnique({
      where: { id: rideId },
      include: {
        user: true,
        building: true
      }
    })

    if (!ride) {
      throw new Error('Ride not found')
    }

    // Find potential matches based on:
    // 1. Same building or locality
    // 2. Similar departure time (¬±30 min window)
    // 3. Active rides only
    const timeWindowStart = new Date(ride.departureTime.getTime() - 30 * 60000)
    const timeWindowEnd = new Date(ride.departureTime.getTime() + 30 * 60000)

    const potentialRides = await prisma.ride.findMany({
      where: {
        id: { not: rideId },
        userId: { not: ride.userId },
        status: 'ACTIVE',
        departureTime: {
          gte: timeWindowStart,
          lte: timeWindowEnd
        },
        OR: [
          { buildingId: ride.buildingId },
          // Could add locality matching here
        ]
      },
      include: {
        user: {
          include: {
            preferences: true
          }
        }
      }
    })

    const matches = []

    for (const potentialRide of potentialRides) {
      // Calculate destination proximity (in meters)
      const destinationDistance = calculateDistance(
        ride.destinationLat,
        ride.destinationLng,
        potentialRide.destinationLat,
        potentialRide.destinationLng
      )

      // Skip if destination too far
      if (destinationDistance > ride.maxDetourKm * 1000) {
        continue
      }

      // Calculate time difference (in minutes)
      const timeDifference = calculateTimeDifference(
        ride.departureTime,
        potentialRide.departureTime
      )

      // Check gender preferences
      if (ride.genderPreference === 'SAME_GENDER' && 
          ride.user.gender !== potentialRide.user.gender) {
        continue
      }

      if (potentialRide.genderPreference === 'SAME_GENDER' && 
          ride.user.gender !== potentialRide.user.gender) {
        continue
      }

      // Calculate match scores
      const scores = calculateMatchScore({
        destinationDistance,
        timeDifference,
        userTrustScore: potentialRide.user.trustScore,
        rideUserId: ride.userId,
        potentialUserId: potentialRide.userId
      })

      // Skip if below minimum threshold
      if (scores.overall < THRESHOLDS.minimumScore) {
        continue
      }

      // Determine confidence level
      let confidence: 'HIGH' | 'MEDIUM' | 'LOW' = 'LOW'
      if (scores.overall >= THRESHOLDS.highConfidence) {
        confidence = 'HIGH'
      } else if (scores.overall >= THRESHOLDS.mediumConfidence) {
        confidence = 'MEDIUM'
      }

      // Calculate benefits
      const estimatedSavings = ride.costPerPerson 
        ? ride.costPerPerson * 0.5 
        : calculateEstimatedSavings(destinationDistance)
      
      const co2Reduction = (destinationDistance / 1000) * 0.21 // kg CO2 per km

      // Create match record
      const match = await prisma.match.create({
        data: {
          sourceRideId: ride.id,
          targetUserId: potentialRide.userId,
          targetRideId: potentialRide.id,
          score: scores.overall,
          confidence,
          destinationProximityScore: scores.destinationProximity,
          timeAlignmentScore: scores.timeAlignment,
          trustScoreCompatibility: scores.trustScore,
          previousInteractionsScore: scores.previousInteractions,
          destinationDistance: Math.round(destinationDistance),
          timeDifference: Math.round(timeDifference),
          estimatedSavings,
          co2Reduction: parseFloat(co2Reduction.toFixed(2)),
          reasons: generateMatchReasons(scores, destinationDistance, timeDifference),
          expiresAt: new Date(Date.now() + 15 * 60000) // 15 minutes
        }
      })

      matches.push(match)

      // Send notification to matched user
      await sendPushNotification(potentialRide.userId, {
        title: 'üéâ Match Found!',
        body: `${ride.user.displayName} from ${ride.building.name} is going to ${ride.destinationName}`,
        data: {
          matchId: match.id,
          rideId: ride.id,
          type: 'new_match'
        }
      })

      // Also notify ride creator
      await sendPushNotification(ride.userId, {
        title: 'üéâ Match Found!',
        body: `${potentialRide.user.displayName} is also going to ${potentialRide.destinationName}`,
        data: {
          matchId: match.id,
          targetRideId: potentialRide.id,
          type: 'new_match'
        }
      })
    }

    return { success: true, matchesFound: matches.length }
  } catch (error) {
    console.error('Matching algorithm error:', error)
    return { success: false, error: 'Matching failed' }
  }
}

function calculateMatchScore(params: {
  destinationDistance: number
  timeDifference: number
  userTrustScore: number
  rideUserId: string
  potentialUserId: string
}): MatchScore {
  const { destinationDistance, timeDifference, userTrustScore } = params

  // Destination proximity score (closer = better)
  // 0-500m: 1.0, 500-1000m: 0.8, 1000-2000m: 0.6, >2000m: 0.4
  let destScore = 1.0
  if (destinationDistance > 2000) destScore = 0.4
  else if (destinationDistance > 1000) destScore = 0.6
  else if (destinationDistance > 500) destScore = 0.8

  // Time alignment score (closer = better)
  // 0-5min: 1.0, 5-15min: 0.9, 15-30min: 0.7, >30min: 0.5
  let timeScore = 1.0
  if (timeDifference > 30) timeScore = 0.5
  else if (timeDifference > 15) timeScore = 0.7
  else if (timeDifference > 5) timeScore = 0.9

  // Trust score (normalized to 0-1)
  const trustScoreNormalized = userTrustScore / 5.0

  // Previous interactions (would need to query database)
  // For now, default to 0.7
  const previousInteractionsScore = 0.7

  // Calculate weighted overall score
  const overall = 
    (destScore * WEIGHTS.destinationProximity) +
    (timeScore * WEIGHTS.timeAlignment) +
    (trustScoreNormalized * WEIGHTS.trustScore) +
    (previousInteractionsScore * WEIGHTS.previousInteractions)

  return {
    destinationProximity: destScore,
    timeAlignment: timeScore,
    trustScore: trustScoreNormalized,
    previousInteractions: previousInteractionsScore,
    overall: parseFloat(overall.toFixed(2))
  }
}

function generateMatchReasons(
  scores: MatchScore,
  distance: number,
  timeDiff: number
): string[] {
  const reasons: string[] = []

  if (scores.destinationProximity > 0.8) {
    reasons.push('destination_proximity')
  }
  if (scores.timeAlignment > 0.8) {
    reasons.push('time_match')
  }
  if (scores.trustScore > 0.85) {
    reasons.push('high_trust_score')
  }
  if (distance < 500) {
    reasons.push('same_destination')
  }
  if (timeDiff < 5) {
    reasons.push('perfect_timing')
  }

  return reasons
}

function calculateEstimatedSavings(distanceMeters: number): number {
  // Rough estimate: ‚Çπ12/km for Uber
  const costPerKm = 12
  const distanceKm = distanceMeters / 1000
  const totalCost = distanceKm * costPerKm
  return Math.round(totalCost * 0.5) // 50% savings by sharing
}

Chat & Messaging (app/actions/messages.ts)
'use server'

import { z } from 'zod'
import { prisma } from '@/lib/prisma'
import { getServerSession } from '@/lib/auth'
import { sendPushNotification } from '@/lib/notifications'
import { revalidatePath } from 'next/cache'

const sendMessageSchema = z.object({
  conversationId: z.string().optional(),
  rideId: z.string().optional(),
  recipientId: z.string(),
  content: z.string().min(1).max(500),
  type: z.enum(['TEXT', 'LOCATION', 'QUICK_REPLY']).default('TEXT')
})

export async function sendMessage(formData: FormData) {
  try {
    const session = await getServerSession()
    if (!session?.user) {
      return { success: false, error: 'Not authenticated' }
    }

    const rawData = {
      conversationId: formData.get('conversationId'),
      rideId: formData.get('rideId'),
      recipientId: formData.get('recipientId'),
      content: formData.get('content'),
      type: formData.get('type') || 'TEXT'
    }

    const validated = sendMessageSchema.parse(rawData)

    // Find or create conversation
    let conversationId = validated.conversationId

    if (!conversationId) {
      const existingConversation = await prisma.conversation.findFirst({
        where: {
          rideId: validated.rideId,
          participants: {
            hasEvery: [session.user.id, validated.recipientId]
          }
        }
      })

      if (existingConversation) {
        conversationId = existingConversation.id
      } else {
        const newConversation = await prisma.conversation.create({
          data: {
            rideId: validated.rideId,
            participants: [session.user.id, validated.recipientId]
          }
        })
        conversationId = newConversation.id
      }
    }

    // Create message
    const message = await prisma.message.create({
      data: {
        conversationId,
        rideId: validated.rideId,
        senderId: session.user.id,
        recipientId: validated.recipientId,
        content: validated.content,
        type: validated.type as any,
        deliveryStatus: 'DELIVERED'
      },
      include: {
        sender: {
          select: {
            id: true,
            displayName: true,
            photoUrl: true
          }
        }
      }
    })

    // Update conversation
    await prisma.conversation.update({
      where: { id: conversationId },
      data: {
        lastMessageAt: new Date(),
        messageCount: { increment: 1 }
      }
    })

    // Send push notification
    await sendPushNotification(validated.recipientId, {
      title: `New message from ${message.sender.displayName}`,
      body: validated.content.substring(0, 100),
      data: {
        messageId: message.id,
        conversationId,
        rideId: validated.rideId,
        type: 'new_message'
      }
    })

    return { success: true, message }
  } catch (error) {
    if (error instanceof z.ZodError) {
      return { success: false, error: error.errors[0].message }
    }
    console.error('Send message error:', error)
    return { success: false, error: 'Failed to send message' }
  }
}

export async function getConversationMessages(conversationId: string) {
  try {
    const session = await getServerSession()
    if (!session?.user) {
      return { success: false, error: 'Not authenticated' }
    }

    const conversation = await prisma.conversation.findUnique({
      where: { id: conversationId }
    })

    if (!conversation || !conversation.participants.includes(session.user.id)) {
      return { success: false, error: 'Not authorized' }
    }

    const messages = await prisma.message.findMany({
      where: { conversationId },
      include: {
        sender: {
          select: {
            id: true,
            displayName: true,
            photoUrl: true
          }
        }
      },
      orderBy: { createdAt: 'asc' }
    })

    // Mark messages as read
    await prisma.message.updateMany({
      where: {
        conversationId,
        recipientId: session.user.id,
        readStatus: 'UNREAD'
      },
      data: {
        readStatus: 'READ',
        readAt: new Date()
      }
    })

    return { success: true, messages }
  } catch (error) {
    console.error('Get messages error:', error)
    return { success: false, error: 'Failed to fetch messages' }
  }
}

export async function markMessageAsRead(messageId: string) {
  try {
    const session = await getServerSession()
    if (!session?.user) {
      return { success: false, error: 'Not authenticated' }
    }

    await prisma.message.update({
      where: {
        id: messageId,
        recipientId: session.user.id
      },
      data: {
        readStatus: 'READ',
        readAt: new Date()
      }
    })

    return { success: true }
  } catch (error) {
    console.error('Mark as read error:', error)
    return { success: false, error: 'Failed to mark as read' }
  }
}


3. Key React Components
Ride Creation Form (app/components/RideCreationForm.tsx)
'use client'

import { useState } from 'react'
import { useRouter } from 'next/navigation'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { Label } from '@/components/ui/label'
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select'
import { Textarea } from '@/components/ui/textarea'
import { Switch } from '@/components/ui/switch'
import { createRide } from '@/app/actions/rides'
import { toast } from 'sonner'
import { MapPin, Clock, Users, DollarSign } from 'lucide-react'

interface Location {
  name: string
  address: string
  lat: number
  lng: number
  placeId?: string
}

export function RideCreationForm() {
  const router = useRouter()
  const [isLoading, setIsLoading] = useState(false)
  const [destination, setDestination] = useState<Location | null>(null)
  const [formData, setFormData] = useState({
    type: 'OWN_CAR',
    departureTime: '',
    flexibilityMinutes: 15,
    totalSeats: 2,
    costSharingEnabled: true,
    estimatedCost: '',
    genderPreference: 'ANY',
    maxDetourKm: 1.0,
    purpose: '',
    notes: ''
  })

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    
    if (!destination) {
      toast.error('Please select a destination')
      return
    }

    setIsLoading(true)

    const data = new FormData()
    data.append('type', formData.type)
    data.append('destinationName', destination.name)
    data.append('destinationAddress', destination.address)
    data.append('destinationLat', destination.lat.toString())
    data.append('destinationLng', destination.lng.toString())
    if (destination.placeId) {
      data.append('destinationPlaceId', destination.placeId)
    }
    data.append('departureTime', formData.departureTime)
    data.append('flexibilityMinutes', formData.flexibilityMinutes.toString())
    data.append('totalSeats', formData.totalSeats.toString())
    data.append('costSharingEnabled', formData.costSharingEnabled.toString())
    if (formData.estimatedCost) {
      data.append('estimatedCost', formData.estimatedCost)
    }
    data.append('genderPreference', formData.genderPreference)
    data.append('maxDetourKm', formData.maxDetourKm.toString())
    if (formData.purpose) {
      data.append('purpose', formData.purpose)
    }
    if (formData.notes) {
      data.append('notes', formData.notes)
    }

    const result = await createRide(data)

    setIsLoading(false)

    if (result.success) {
      toast.success('Ride created! Looking for matches...')
      router.push(`/rides/${result.rideId}`)
    } else {
      toast.error(result.error || 'Failed to create ride')
    }
  }

  return (
    <form onSubmit={handleSubmit} className="space-y-6 p-4">
      {/* Destination Search */}
      <div className="space-y-2">
        <Label htmlFor="destination">Where are you going?</Label>
        <DestinationSearch 
          onSelect={setDestination}
          selected={destination}
        />
      </div>

      {/* Ride Type */}
      <div className="space-y-2">
        <Label htmlFor="type">Ride Type</Label>
        <Select
          value={formData.type}
          onValueChange={(value) => setFormData({ ...formData, type: value })}
        >
          <SelectTrigger>
            <SelectValue />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="OWN_CAR">üöó Own Car</SelectItem>
            <SelectItem value="SHARED_CAB">üöñ Shared Cab</SelectItem>
            <SelectItem value="PUBLIC_TRANSPORT">üöå Public Transport</SelectItem>
            <SelectItem value="WALKING">üö∂ Walking</SelectItem>
            <SelectItem value="CYCLING">üö¥ Cycling</SelectItem>
          </SelectContent>
        </Select>
      </div>

      {/* Departure Time */}
      <div className="space-y-2">
        <Label htmlFor="departureTime">When are you leaving?</Label>
        <Input
          id="departureTime"
          type="datetime-local"
          value={formData.departureTime}
          onChange={(e) => setFormData({ ...formData, departureTime: e.target.value })}
          required
          min={new Date().toISOString().slice(0, 16)}
        />
      </div>

      {/* Seats (if applicable) */}
      {(formData.type === 'OWN_CAR' || formData.type === 'SHARED_CAB') && (
        <div className="space-y-2">
          <Label htmlFor="seats">Available Seats</Label>
          <Select
            value={formData.totalSeats.toString()}
            onValueChange={(value) => setFormData({ ...formData, totalSeats: parseInt(value) })}
          >
            <SelectTrigger>
              <SelectValue />
            </SelectTrigger>
            <SelectContent>
              {[1, 2, 3, 4, 5, 6].map((num) => (
                <SelectItem key={num} value={num.toString()}>
                  {num} {num === 1 ? 'seat' : 'seats'}
                </SelectItem>
              ))}
            </SelectContent>
          </Select>
        </div>
      )}

      {/* Cost Sharing */}
      <div className="flex items-center justify-between">
        <Label htmlFor="costSharing">Cost Sharing</Label>
        <Switch
          id="costSharing"
          checked={formData.costSharingEnabled}
          onCheckedChange={(checked) => setFormData({ ...formData, costSharingEnabled: checked })}
        />
      </div>

      {formData.costSharingEnabled && (
        <div className="space-y-2">
          <Label htmlFor="cost">Estimated Cost (‚Çπ)</Label>
          <Input
            id="cost"
            type="number"
            placeholder="250"
            value={formData.estimatedCost}
            onChange={(e) => setFormData({ ...formData, estimatedCost: e.target.value })}
          />
        </div>
      )}

      {/* Gender Preference */}
      <div className="space-y-2">
        <Label htmlFor="gender">Gender Preference</Label>
        <Select
          value={formData.genderPreference}
          onValueChange={(value) => setFormData({ ...formData, genderPreference: value })}
        >
          <SelectTrigger>
            <SelectValue />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="ANY">Any</SelectItem>
            <SelectItem value="SAME_GENDER">Same Gender Only</SelectItem>
            <SelectItem value="MALE">Male Only</SelectItem>
            <SelectItem value="FEMALE">Female Only</SelectItem>
          </SelectContent>
        </Select>
      </div>

      {/* Notes */}
      <div className="space-y-2">
        <Label htmlFor="notes">Additional Notes (Optional)</Label>
        <Textarea
          id="notes"
          placeholder="Any specific details..."
          value={formData.notes}
          onChange={(e) => setFormData({ ...formData, notes: e.target.value })}
          rows={3}
        />
      </div>

      {/* Submit */}
      <Button 
        type="submit" 
        className="w-full" 
        disabled={isLoading || !destination}
      >
        {isLoading ? 'Creating...' : 'Create Ride'}
      </Button>
    </form>
  )
}

This comprehensive guide provides the foundation for building RideShare Local. Would you like me to continue with:
Frontend components (Match cards, Chat interface, Map views)
Real-time WebSocket implementation
Push notification setup
Deployment configuration
Testing suites
API documentation
Let me know which section you'd like me to expand next!

